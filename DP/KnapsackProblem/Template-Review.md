# 一份不错的参考资料
https://blog.csdn.net/yandaoqiusheng/article/details/84782655
# 0-1 knapsack problem 01 背包问题
## 题目
有N件物品和一个容量为V的背包。放入第i件物品耗费的费用是Ci，得到的价值是Wi。求解将哪些物品装入背包可使价值总和最大。
F[i,v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值.
$F[i,v]=max(F(i-1,v),F(i-1,v-ci)+wi)$
那么可以得到公式：
```
for i=1:N:
    for v=ci:V:
        F[i,v]=max(F(i-1,v),F(i-1,v-ci)+wi)
```
## 优化空间复杂度
注意更新是需要左和左上之前的，又注意是每次更新过后旧值就不能再用了，又注意到式子中F所以就可以直接写出优化条件为：
```
for i=1:N:
    for v=V:ci:
        F[v]=max(F(v),F(v-ci)+wi)
```

# 完全背包问题
## 题目
有N种物品和一个容量为V的背包，每种物品都有无限件可用。放入第i种物品的费用是Ci，价值是Wi。求解：将哪些物品装入背包，可使这些物品的耗费的费用总和不超过背包容量，且价值总和最大。
如果仍然按照解01背包时的思路，令F[i,v]表示前i种物品恰放入一个容量v的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程:

$F[i,v]=max(F[i-1,v-k*ci]+k*wi \quad | \quad 0<=k*ci<=v \ )$

这样做循环的话算法复杂度是$O(NV\sum{\frac{V}{C_i}})$，

## 可能的优化
一个可能的优化是根据物品性价比来排序，然后先放入性价比高的物品。

转换成代码就是：
不对。还没写好。
```
ValueDCost=[wi/ci for wi,ci in W,C]
sort(ValueCost,reverse=True)
for i=1:N:
    for v=V:ci:
        F[i,v]=max(F(i-1,v),F(i-1,v-ci)+wi)
```

## 转化为01背包
高效的转化方法是：把第i种物品拆成费用为$C_i2^k$、价值为$W_i2^k$ 的若干件物品，其中k取遍满足$C_i2^k<=V$ 的非负整数。这是二进制的思想。因为，不管最优策略选几件第i 种物品，其件数写成二进制后，总可以表示成若干个$2^k$ 件物品的和。这样一来就把每种物品拆成$O(log ⌊V /Ci⌋)$ 件物
品，是一个很大的改进。整个时间复杂度就变为$O(NVlog2(V/C[i]))$

## 优化时间复杂度至O(NV)
设F[i][j]表示出在前i种物品中选取若干件物品放入容量为j的背包所得的最大价值。则有
$F[i,v] = max(F[i-1,v]; F[i,v-ci]+wi)$

为什么这个算法就可行呢？首先想想为什么01 背包中要按照v 递减的次序来循环。让v递减是为了保证第i次循环中的状态F[i,v]是由状态F[i-1,v-Ci]递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果F[i-1;v-Ci]。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果F[i;v-Ci],所以就可以并且必须采用v递增的顺序循环。这就是这个简单的程序为何成立的道理。


另一种推导方法和01背包问题类似,我们可以对空间复杂度利用一维数组进行优化.我们先显示的写出完全背包的二维状态转移方程:
```
f[i , j ] = max( f[i-1,j] , f[i-1,j-v]+w ,  f[i-1,j-2*v]+2*w , f[i-1,j-3*v]+3*w , .....)
f[i , j-v]= max(            f[i-1,j-v]   ,  f[i-1,j-2*v] + w , f[i-1,j-2*v]+2*w , .....)
```
由上两式，可得递推关系：   
```
f[i][j]=max(f[i,j-v]+w , f[i-1][j]) 
```

将得到的递推式用一维表示,得到状态转移方程如下:
```
f[j] = max(f[ j ],f[ j-v[i] ]+w[i]);
```
## 完全背包和01背包异同
实现时候只有内循环的次序不同。
# 多重背包问题
## 题目
有N种物品和一个容量为V的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci，价值是Wi。求解将哪些物品装入背包可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。
## 基本算法
这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可。
因为对于第i种物品有Mi+1种策略：取0件，取1件……取Mi件。令F[i; v]表示前i种物品恰放入一个容量为v的背包的最大价值，则有状态转移方程：

$F[i,v]=max(F[i-1,v-k*ci]+k*wi \quad | \quad 0<=k<=Mi \ )$

复杂度是$O(V\sum Mi)$。

## 二进制优化
转化为01 背包求解：把第i 种物品换成Mi 件01背包中的物品，则得到了物品数为Mi 的01 背包问题。直接求解之，复杂度仍然是$O(V\sum Mi)$。

但是我们期望将它转化为01 背包问题之后，能够像完全背包一样降低复杂度。仍然考虑二进制的思想，我们考虑把第i种物品换成若干件物品，使得原问题中第i种物品可取的每种策略————取0...Mi件————均能等价于取若干件代换以后的物品。另外，取超过Mi 件的策略必不能出现。
方法是：将第i种物品分成若干件01背包中的物品，其中每件物品有一个系数。这件物品的费用和价值均是原来的费用和价值乘以这个系数。令这些系数分别为
$1,2,2^2,...,2^{k-1},Mi-2^k+1$，且k 是满足Mi - 2^k + 1 > 0 的最大整数。例如，如果Mi为13，则相应的k = 3，这种最多取13件的物品应被分成系数分别为1; 2; 4; 6 的四件物品。

对应的C++的代码：
```C++
#include <iostream>
#include <string.h>
#include <stdio.h>
 
using namespace std;
const int N = 1005;
 
int dp[N];
int c[N],w[N],num[N];
int n,m;
 
void ZeroOne_Pack(int cost,int weight,int n)
{
    for(int i=n; i>=cost; i--)
        dp[i] = max(dp[i],dp[i-cost] + weight);
}
 
void Complete_Pack(int cost,int weight,int n)
{
    for(int i=cost; i<=n; i++)
        dp[i] = max(dp[i],dp[i-cost] + weight);
}
 
int Multi_Pack(int c[],int w[],int num[],int n,int m)
{
    memset(dp,0,sizeof(dp));
    for(int i=1; i<=n; i++)
    {
        if(num[i]*c[i] > m)
            Complete_Pack(c[i],w[i],m);
        else
        {
            int k = 1;
            while(k < num[i])
            {
                ZeroOne_Pack(k*c[i],k*w[i],m);
                num[i] -= k;
                k <<= 1;
            }
            ZeroOne_Pack(num[i]*c[i],num[i]*w[i],m);
        }
    }
    return dp[m];
}
 
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        cin>>m>>n;
        for(int i=1; i<=n; i++)
            cin>>c[i]>>w[i]>>num[i];
        cout<<Multi_Pack(c,w,num,n,m)<<endl;
    }
    return 0;
}
```

这样就将第i 种物品分成了O(logMi) 种物品， 将原问题转化为了复杂度为$O(V\sum logMi)$ 的01 背包问题，是很大的改进。

## 利用DP优化
当问题是“每种有若干件的物品能否填满给定容量的背包”，只须考虑填满背包的可行性，不需考虑每件物品的价值时，多重背包问题同样有O(V N) 复杂度的算法。例如，可以使用单调队列的数据结构，优化基本算法的状态转移方程，使每个状态的值可以以均摊O(1) 的时间求解。
下面介绍一种实现较为简单的O(V N) 复杂度解多重背包问题的算法。它的基本思想是这样的：设F[i，j] 表示“用了前i 种物品填满容量为j 的背包后，最多还剩下几个第i 种物品可用”，如果F[i; j] = -1 则说明这种状态不可行，若可行应满足0 <= F[i; j] <= Mi。

递推求F[i; j] 的伪代码如下：

![](%202020-07-25-23-27-51.png)

